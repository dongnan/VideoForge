# 监控脚本优化说明

## 📋 优化概述

对 VideoForge 的监控脚本进行了全面优化，实现了**零硬编码**、**动态路径获取**和**严谨的进程查询**。

---

## 🎯 主要优化点

### 1. **通过脚本名查询进程（更严谨）**

#### ❌ 旧版（不严谨）
```bash
# 使用固定 PID，进程重启后失效
PYTHON_PID=47950
FFMPEG_PID=47959
```

**问题**：
- 进程重启后 PID 会变化
- 无法自动适应新进程
- 需要手动更新脚本

#### ✅ 新版（严谨）
```bash
# 通过脚本名动态查找进程
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode" | head -1)
FFMPEG_PID=$(pgrep -P $PYTHON_PID ffmpeg 2>/dev/null | head -1)
```

**优势**：
- 自动识别运行中的转码任务
- 支持进程重启
- 无需手动维护

---

### 2. **动态获取所有路径（零硬编码）**

#### ❌ 旧版（硬编码）
```bash
# 硬编码路径
OUTPUT_DIR="/Volumes/Disk0/Processing"
SOURCE_DIR="/Volumes/Disk0/DongNan/Nextcloud/视频/"
LOG_FILE="logs/videoforge_$(date +%Y%m%d).log"
```

**问题**：
- 路径变更时需要修改脚本
- 不同任务需要不同的脚本版本
- 无法通用

#### ✅ 新版（动态获取）
```bash
# 从进程命令行中提取参数
FULL_CMD=$(ps -p $PYTHON_PID -o command=)

# 提取源目录
SOURCE_DIR=$(echo "$FULL_CMD" | sed -n 's/.*transcode[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')

# 提取输出目录
OUTPUT_DIR=$(echo "$FULL_CMD" | sed -n 's/.*-o[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')
if [ -z "$OUTPUT_DIR" ]; then
    OUTPUT_DIR=$(echo "$FULL_CMD" | sed -n 's/.*--output[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')
fi

# 提取编码格式
CODEC=$(echo "$FULL_CMD" | sed -n 's/.*--codec[[:space:]]\+\([^[:space:]]*\).*/\1/p')

# 提取质量
QUALITY=$(echo "$FULL_CMD" | sed -n 's/.*--quality[[:space:]]\+\([^[:space:]]*\).*/\1/p')

# 日志目录（脚本运行时获取）
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="$SCRIPT_DIR/logs"
LOG_FILE="$LOG_DIR/videoforge_$(date +%Y%m%d).log"
```

**优势**：
- 完全无硬编码，自适应任意路径
- 一个脚本适用所有转码任务
- 维护成本极低

---

### 3. **从进程中提取当前处理文件**

#### ✅ 新版（智能提取）
```bash
# 从 FFmpeg 进程命令行中提取当前处理的文件
CURRENT_FILE=$(ps -p $FFMPEG_PID -o command= | grep -o -- '-i [^[:space:]]*' | cut -d' ' -f2 | tr -d '"')

if [ -n "$CURRENT_FILE" ]; then
    echo "正在处理: $(basename "$CURRENT_FILE")"
    
    # 计算输出文件路径
    RELATIVE_PATH="${CURRENT_FILE#$SOURCE_DIR/}"
    OUTPUT_FILE="$OUTPUT_DIR/$RELATIVE_PATH"
    
    # 显示进度
    if [ -f "$OUTPUT_FILE" ]; then
        ORIG_SIZE=$(stat -f%z "$CURRENT_FILE")
        OUT_SIZE=$(stat -f%z "$OUTPUT_FILE")
        PROGRESS=$((OUT_SIZE * 100 / ORIG_SIZE))
        echo "进度: ${PROGRESS}%"
    fi
fi
```

**优势**：
- 实时显示当前处理文件
- 自动计算转码进度
- 无需日志辅助

---

## 📂 优化后的脚本

### 1. `check_transcode_status.sh`
快速状态检查脚本

**特性**：
- ✅ 通过脚本名查找进程
- ✅ 动态提取所有参数
- ✅ 显示当前处理文件
- ✅ 零硬编码

**使用**：
```bash
# 单次查看
bash check_transcode_status.sh

# 实时监控（每2秒刷新）
watch -n 2 bash check_transcode_status.sh
```

---

### 2. `monitor_long_task.sh`
长时间任务详细监控

**特性**：
- ✅ 完整的进程信息
- ✅ 详细的处理进度
- ✅ 输出目录统计
- ✅ 磁盘空间监控
- ✅ 系统资源状态

**使用**：
```bash
# 单次查看
bash monitor_long_task.sh

# 实时监控（每10秒刷新）
watch -n 10 bash monitor_long_task.sh
```

---

### 3. `daily_report.sh`
每日进度报告

**特性**：
- ✅ 今日统计
- ✅ 总体进度
- ✅ 错误摘要
- ✅ 自动保存报告

**使用**：
```bash
# 生成今日报告
bash daily_report.sh

# 查看历史报告
cat logs/daily_reports.log
```

---

## 🔍 技术细节

### 进程命令行解析

示例命令行：
```bash
python videoforge.py transcode "/Volumes/Disk0/DongNan/Nextcloud/视频/" -o /Volumes/Disk0/Processing --codec h264 --quality medium --smart-skip
```

提取逻辑：
```bash
# 1. 获取完整命令
FULL_CMD=$(ps -p $PID -o command=)

# 2. 提取位置参数（transcode 后的第一个参数）
SOURCE=$(echo "$FULL_CMD" | sed -n 's/.*transcode[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')

# 3. 提取选项参数
OUTPUT=$(echo "$FULL_CMD" | sed -n 's/.*-o[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')

# 4. 检测布尔标志
echo "$FULL_CMD" | grep -q "\-\-smart-skip" && echo "智能跳过: 启用"
```

### FFmpeg 输入文件提取

FFmpeg 命令示例：
```bash
ffmpeg -i "/path/to/input.mp4" -c:v libx264 ... "/path/to/output.mp4"
```

提取逻辑：
```bash
# 匹配 '-i' 参数后的文件路径
CURRENT_FILE=$(ps -p $FFMPEG_PID -o command= | grep -o -- '-i [^[:space:]]*' | cut -d' ' -f2 | tr -d '"')
```

### 相对路径计算

```bash
# 源文件: /Volumes/Disk0/DongNan/Nextcloud/视频/行车视频/file.mp4
# 源目录: /Volumes/Disk0/DongNan/Nextcloud/视频/
# 输出目录: /Volumes/Disk0/Processing

# 计算相对路径
RELATIVE_PATH="${CURRENT_FILE#$SOURCE_DIR/}"  # 行车视频/file.mp4

# 构建输出文件路径
OUTPUT_FILE="$OUTPUT_DIR/$RELATIVE_PATH"  # /Volumes/Disk0/Processing/行车视频/file.mp4
```

---

## ✅ 验证对比

### 场景 1: 进程重启

#### 旧版
```bash
# 需要手动更新 PID
PYTHON_PID=47950  # ❌ 进程重启后失效
```

#### 新版
```bash
# 自动查找
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode" | head -1)  # ✅ 自动适应
```

---

### 场景 2: 不同转码任务

#### 旧版
```bash
# 任务 A
OUTPUT_DIR="/Volumes/Disk0/Processing"  # ❌ 硬编码

# 任务 B（需要修改脚本）
OUTPUT_DIR="/Volumes/Disk0/OtherOutput"  # ❌ 需要另一个脚本
```

#### 新版
```bash
# 任务 A 和任务 B 都使用同一个脚本
OUTPUT_DIR=$(echo "$FULL_CMD" | sed -n 's/.*-o[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')
# ✅ 自动适应任意输出目录
```

---

### 场景 3: 多个转码任务并行

#### 旧版
```bash
# 只能监控一个固定 PID 的任务
PYTHON_PID=47950  # ❌ 无法切换
```

#### 新版
```bash
# 方法 1: 监控最新任务
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode" | head -1)

# 方法 2: 查看所有任务
pgrep -f "python.*videoforge.py transcode"  # 显示所有 PID

# 方法 3: 指定特定任务（通过参数特征）
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode.*Processing")
```

---

## 📊 性能影响

所有优化对性能影响极小：

- `pgrep` 查询：< 10ms
- 命令行解析：< 5ms
- 文件统计：取决于文件数量

---

## 🎯 最佳实践

### 1. 实时监控推荐配置

```bash
# 快速检查（每2秒）
watch -n 2 bash check_transcode_status.sh

# 详细监控（每10秒）
watch -n 10 bash monitor_long_task.sh
```

### 2. 定时报告（Cron）

```bash
# 每天 20:00 生成报告
0 20 * * * cd /path/to/VideoForge && bash daily_report.sh >> /tmp/report.log 2>&1
```

### 3. 脚本调试

```bash
# 查看提取的参数
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode" | head -1)
ps -p $PYTHON_PID -o command=

# 测试正则提取
FULL_CMD="python videoforge.py transcode /source -o /output"
echo "$FULL_CMD" | sed -n 's/.*-o[[:space:]]\+\([^[:space:]]*\).*/\1/p'
```

---

## 🔮 未来增强

可能的改进方向：

1. **多任务并行监控**
   - 自动检测所有运行中的转码任务
   - 分别显示每个任务的状态

2. **Web 仪表板**
   - 将监控数据导出为 JSON
   - 提供 Web UI 实时监控

3. **智能告警**
   - 磁盘空间不足告警
   - 任务失败通知
   - 性能异常检测

4. **历史数据分析**
   - 转码速度趋势
   - 跳过率统计
   - 压缩率分析

---

## 📝 总结

通过这次优化，实现了：

✅ **零硬编码** - 所有路径动态获取  
✅ **自动适应** - 支持任意转码任务  
✅ **严谨可靠** - 通过脚本名查找进程  
✅ **易于维护** - 一次编写，永久使用  

脚本现在是**真正通用**的监控工具，无需任何修改即可适应各种转码场景！
