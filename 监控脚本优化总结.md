# 监控脚本优化总结

## 📋 优化背景

根据用户反馈，原监控脚本存在以下问题：

1. **进程查询不严谨** - 使用固定PID，进程重启后失效
2. **路径硬编码** - 所有路径写死在脚本中，不够通用
3. **无法动态适应** - 无法从运行中的进程获取配置信息

## 🎯 优化目标

实现**零硬编码**、**动态路径获取**的通用监控脚本。

---

## ✅ 核心改进

### 1. 进程查询严谨化

#### 问题
```bash
# 旧版：硬编码PID
PYTHON_PID=47950
FFMPEG_PID=47959
```

**缺陷**：
- 进程重启后 PID 改变，脚本失效
- 需要手动更新脚本
- 无法自动适应

#### 解决方案
```bash
# 新版：通过脚本名动态查找
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode" | head -1)
FFMPEG_PID=$(pgrep -P $PYTHON_PID ffmpeg 2>/dev/null | head -1)
```

**优势**：
- ✅ 自动识别运行中的任务
- ✅ 支持进程重启
- ✅ 无需手动维护

---

### 2. 动态路径提取

#### 问题
```bash
# 旧版：所有路径硬编码
OUTPUT_DIR="/Volumes/Disk0/Processing"
SOURCE_DIR="/Volumes/Disk0/DongNan/Nextcloud/视频/"
LOG_FILE="logs/videoforge_$(date +%Y%m%d).log"
```

**缺陷**：
- 路径变更需要修改脚本
- 不同任务需要不同脚本
- 维护成本高

#### 解决方案
```bash
# 从进程命令行中动态提取所有参数
FULL_CMD=$(ps -p $PYTHON_PID -o command=)

# 提取源目录（transcode 后的第一个参数）
SOURCE_DIR=$(echo "$FULL_CMD" | sed -n 's/.*transcode[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')

# 提取输出目录（-o 或 --output）
OUTPUT_DIR=$(echo "$FULL_CMD" | sed -n 's/.*-o[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')
if [ -z "$OUTPUT_DIR" ]; then
    OUTPUT_DIR=$(echo "$FULL_CMD" | sed -n 's/.*--output[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')
fi

# 提取编码格式
CODEC=$(echo "$FULL_CMD" | sed -n 's/.*--codec[[:space:]]\+\([^[:space:]]*\).*/\1/p')

# 提取质量
QUALITY=$(echo "$FULL_CMD" | sed -n 's/.*--quality[[:space:]]\+\([^[:space:]]*\).*/\1/p')

# 日志路径（脚本运行时动态获取）
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="$SCRIPT_DIR/logs"
LOG_FILE="$LOG_DIR/videoforge_$(date +%Y%m%d).log"
```

**优势**：
- ✅ 完全零硬编码
- ✅ 一个脚本适用所有任务
- ✅ 自动适应任意路径

---

### 3. 实时文件追踪

#### 新增功能
```bash
# 从 FFmpeg 进程中提取当前处理的文件
CURRENT_FILE=$(ps -p $FFMPEG_PID -o command= | grep -o -- '-i [^[:space:]]*' | cut -d' ' -f2 | tr -d '"')

if [ -n "$CURRENT_FILE" ]; then
    echo "正在处理: $(basename "$CURRENT_FILE")"
    
    # 计算相对路径
    RELATIVE_PATH="${CURRENT_FILE#$SOURCE_DIR/}"
    OUTPUT_FILE="$OUTPUT_DIR/$RELATIVE_PATH"
    
    # 显示进度
    if [ -f "$OUTPUT_FILE" ]; then
        ORIG_SIZE=$(stat -f%z "$CURRENT_FILE" 2>/dev/null)
        OUT_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null)
        if [ -n "$ORIG_SIZE" ] && [ -n "$OUT_SIZE" ] && [ "$ORIG_SIZE" -gt 0 ]; then
            PROGRESS=$((OUT_SIZE * 100 / ORIG_SIZE))
            echo "进度: ${PROGRESS}%"
        fi
    fi
fi
```

**优势**：
- ✅ 实时显示当前文件
- ✅ 自动计算转码进度
- ✅ 无需日志辅助

---

## 📂 优化后的脚本

### 1. check_transcode_status.sh
**快速状态检查**

**特性**：
- 通过脚本名查找进程 ✅
- 动态提取所有参数 ✅
- 显示当前处理文件 ✅
- 零硬编码 ✅

**使用**：
```bash
# 单次查看
bash check_transcode_status.sh

# 实时监控（每2秒刷新）
watch -n 2 bash check_transcode_status.sh
```

---

### 2. monitor_long_task.sh
**长时间任务监控**

**特性**：
- 完整进程信息 ✅
- 详细处理进度 ✅
- 输出目录统计 ✅
- 磁盘空间监控 ✅
- 系统资源状态 ✅

**使用**：
```bash
# 单次查看
bash monitor_long_task.sh

# 实时监控（每10秒刷新）
watch -n 10 bash monitor_long_task.sh
```

---

### 3. daily_report.sh
**每日进度报告**

**特性**：
- 今日统计 ✅
- 总体进度 ✅
- 错误摘要 ✅
- 自动保存报告 ✅

**使用**：
```bash
# 生成今日报告
bash daily_report.sh

# 查看历史报告
cat logs/daily_reports.log
```

---

## 🔍 技术实现细节

### 进程命令行解析

**示例命令**：
```bash
python videoforge.py transcode "/Volumes/Disk0/DongNan/Nextcloud/视频/" \
  -o /Volumes/Disk0/Processing \
  --codec h264 \
  --quality medium \
  --smart-skip
```

**提取逻辑**：
```bash
# 1. 获取完整命令
FULL_CMD=$(ps -p $PID -o command=)

# 2. 提取位置参数（transcode 后第一个）
SOURCE=$(echo "$FULL_CMD" | sed -n 's/.*transcode[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')

# 3. 提取选项参数
OUTPUT=$(echo "$FULL_CMD" | sed -n 's/.*-o[[:space:]]\+\([^[:space:]]*\).*/\1/p' | tr -d '"')

# 4. 检测布尔标志
echo "$FULL_CMD" | grep -q "\-\-smart-skip" && echo "智能跳过: 启用"
```

### FFmpeg 输入文件提取

**FFmpeg 命令示例**：
```bash
ffmpeg -i "/path/to/input.mp4" -c:v libx264 ... "/path/to/output.mp4"
```

**提取逻辑**：
```bash
# 匹配 '-i' 参数后的文件路径
CURRENT_FILE=$(ps -p $FFMPEG_PID -o command= | \
  grep -o -- '-i [^[:space:]]*' | \
  cut -d' ' -f2 | \
  tr -d '"')
```

### 相对路径计算

```bash
# 示例
# 源文件: /Volumes/Disk0/DongNan/Nextcloud/视频/行车视频/file.mp4
# 源目录: /Volumes/Disk0/DongNan/Nextcloud/视频/
# 输出目录: /Volumes/Disk0/Processing

# 计算相对路径（Shell 字符串操作）
RELATIVE_PATH="${CURRENT_FILE#$SOURCE_DIR/}"
# 结果: 行车视频/file.mp4

# 构建输出文件路径
OUTPUT_FILE="$OUTPUT_DIR/$RELATIVE_PATH"
# 结果: /Volumes/Disk0/Processing/行车视频/file.mp4
```

---

## 📊 优势对比

| 特性 | 旧版 | 新版 |
|------|------|------|
| 进程查询方式 | 固定PID ❌ | 脚本名匹配 ✅ |
| 路径配置 | 硬编码 ❌ | 动态提取 ✅ |
| 适应性 | 单任务 ❌ | 任意任务 ✅ |
| 维护成本 | 高 ❌ | 零维护 ✅ |
| 进程重启支持 | ❌ | ✅ |
| 多任务兼容 | ❌ | ✅ |
| 当前文件追踪 | ❌ | ✅ |
| 进度计算 | ❌ | ✅ |

---

## 🎯 适用场景

优化后的脚本适用于：

✅ **任意源目录和输出目录**  
✅ **进程重启后自动适应**  
✅ **多个转码任务并行**  
✅ **不同编码格式和质量**  
✅ **长时间后台任务监控**  

---

## 🧪 测试验证

### 场景 1: 进程重启

```bash
# 旧版
PYTHON_PID=47950  # ❌ 重启后失效

# 新版
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode")  # ✅ 自动适应
```

### 场景 2: 不同转码任务

```bash
# 任务 A
python videoforge.py transcode /pathA -o /outputA --codec h264

# 任务 B
python videoforge.py transcode /pathB -o /outputB --codec h265

# 同一个监控脚本自动适应两个任务 ✅
```

### 场景 3: 多任务并行

```bash
# 查看所有运行中的转码任务
pgrep -f "python.*videoforge.py transcode"

# 监控最新任务
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode" | head -1)

# 监控特定任务（通过输出目录特征）
PYTHON_PID=$(pgrep -f "python.*videoforge.py transcode.*Processing")
```

---

## 📝 使用指南

### 基本使用

```bash
# 快速检查
bash check_transcode_status.sh

# 详细监控
bash monitor_long_task.sh

# 每日报告
bash daily_report.sh
```

### 实时监控

```bash
# 快速检查（每2秒刷新）
watch -n 2 bash check_transcode_status.sh

# 详细监控（每10秒刷新）
watch -n 10 bash monitor_long_task.sh
```

### 查看历史

```bash
# 查看历史报告
cat logs/daily_reports.log

# 查看实时日志
tail -f logs/videoforge_$(date +%Y%m%d).log
```

### 定时任务（Cron）

```bash
# 每天 20:00 生成报告
0 20 * * * cd /path/to/VideoForge && bash daily_report.sh >> /tmp/report.log 2>&1
```

---

## 🔮 未来增强

可能的改进方向：

1. **多任务并行监控**
   - 自动检测所有运行中的转码任务
   - 分别显示每个任务的状态

2. **Web 仪表板**
   - 将监控数据导出为 JSON
   - 提供 Web UI 实时监控

3. **智能告警**
   - 磁盘空间不足告警
   - 任务失败通知
   - 性能异常检测

4. **历史数据分析**
   - 转码速度趋势
   - 跳过率统计
   - 压缩率分析

---

## 📚 相关文档

- **详细说明**: `docs/监控脚本优化说明.md`
- **项目结构**: `PROJECT_STRUCTURE.md`
- **使用指南**: `长时间任务指南.md`
- **任务总结**: `任务总结.md`

---

## 💡 总结

通过这次优化，实现了：

✅ **零硬编码** - 所有路径动态获取  
✅ **自动适应** - 支持任意转码任务  
✅ **严谨可靠** - 通过脚本名查找进程  
✅ **易于维护** - 一次编写，永久使用  
✅ **功能丰富** - 实时追踪、进度计算  

**脚本现在是真正通用的监控工具，无需任何修改即可适应各种转码场景！**

---

*优化日期: 2025-11-09*  
*版本: 2.0*
